# * ---------------------------------------------------------- * #
# Title：Type sample code
# 
# 参考ページ
# - https://www.tohoho-web.com/python/index.html
# 
# 実行方法：fn + f5

import math
import datetime

# * ---------------------------------------------------------- * #
# 整数(int)

num = 1234 # 10進数 1234

# ポイント：0o(0O), 0x(0X), 0b(0B) はそれぞれ8進数、16進数、2進数

num = 0b11000100   #  2進数 (0b/0Bで始まる数値は 2進数とみなされる) binaryのb
num = 0o777        #  8進数 (0o/0Oで始まる数値は 8進数とみなされる) octal numberのo
num = 0xffff       # 16進数 (0x/0Xで始まる数値は16進数とみなされる) hexadecimalのx.ここはhじゃないんね


# * ---------------------------------------------------------- * #
# 長整数(long)
# ポイント：Python2.0で、intで扱えないバカデカい数はlongで扱っていた。
#         扱うときは数字の末尾にl or Lをつける。Lの方が数字の1と混同しないのでおすすめ
#         Python3.0ではintの最大値最小値に制限がなくなったのでintを使えばよし
#         ただし、計算量が増えればその分処理は重くなることは留意すべし。

# ちなみに長い数を区切ってわかりやすく見せたい場合はアンダーバー_が使える
num = 123_456_789; print(num); #123456789 出力は変わらないが、コード上での見た目は綺麗になる

# * ---------------------------------------------------------- * #
# 浮動小数点数(float)
# ポイント：Pythonではデフォルトで倍精度(53bits)の演算を行う。
#         CS_浮動小数点数表現における単精度・倍精度の比較
#         https://scrapbox.io/knowledgeboxEngawa/CS_%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E6%95%B0%E8%A1%A8%E7%8F%BE%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%8D%98%E7%B2%BE%E5%BA%A6%E3%83%BB%E5%80%8D%E7%B2%BE%E5%BA%A6%E3%81%AE%E6%AF%94%E8%BC%83
#         要はPythonのfloat表現は高度な計算でも誤差少なく処理できますよってカンジでございやす。
#         なお、e2 は 10の2乗を意味します。eはExponentのe.Exponentは10のべき乗の意。

num = 1.234;  print(num); # 浮動小数点数 
num = 1.2e3;  print(num); # 浮動小数点数の指数表記 1.2 * 10**3  -> 1200.0
num = 1.2E-3; print(num); # 浮動小数点数の指数表記 1.2 * 10**-3 -> 0.0012

# * ---------------------------------------------------------- * #
# 虚数(complex)
# ポイント：数字末尾にJ or jをつけること
num = 4J; print(num); # ターミナルでの表記は4jになる

# * ---------------------------------------------------------- * #
# 論理値(bool)
# ポイント：TrueとFalseは先頭大文字で！でないと変数として認識されちゃいます
judge = True; print(judge); 
judge = False; print(judge); 
# judge = true # 小文字だと変数判定がおります。NameError: name 'true' is not defined

# * ---------------------------------------------------------- * #
# 値無し(None)
# ポイント：値が存在しないことを指します。JSのnullと同じ概念。0や""とも扱いが異なるので注意！
#         こちらも先頭は大文字で。

# None、Supreme店員が好きそうな型だ
boxlogo_XL_size = None; print(boxlogo_XL_size); #ボックスロゴ、XLない
boxlogo_L_size = None; boxlogo_M_size = None; boxlogo_S_size = None; boxlogo_All_size = None; print(boxlogo_L_size,boxlogo_M_size,boxlogo_S_size,boxlogo_All_size,"もういい？"); #Lない、Mない、Sない、全部ないもういい？
# https://youtu.be/a-_xgElVds0?si=YHtqIaHhXnVqneeU

# * ---------------------------------------------------------- * #
# 文字列(str)
# ポイント：文字列はダブルクォーテーション、あるいはシングルクォーテーションで囲む
str_doubleq = "ダブルクォーテーションで囲んだ文字列"; print(str_doubleq); # ダブルクォーテーションで囲んだ文字列
str_singleq = 'シングルクォーテーションで囲んだ文字列'; print(str_singleq); # シングルクォーテーションで囲んだ文字列

# ポイント：ダブルクォーテーション""で囲んだ文字列の中ではシングルクォーテーション囲み''が、
#         シングルクォーテーション''で囲んだ文字列の中ではダブルクォーテーション囲み””が使える
str_example_sentence = "私の名前は'あかさたな　太郎'です"; print(str_example_sentence); # 私の名前は'あかさたな　太郎'です
str_example_sentence = '"あかさたな　太郎"、だと…！？'; print(str_example_sentence); # "あかさたな　太郎"、だと…！？

# ポイント：ダブルクォーテーションやシングルクォーテーションを文中で使いたい場合はエスケープシーケンスを使いましょう
str_example_sentence = "こうすると\"が文中で使える"; print(str_example_sentence); # こうすると"が文中で使える
str_example_sentence = 'こうすると\'が文中で使える'; print(str_example_sentence); # こうすると'が文中で使える

# * ---------------------------------------------------------- * #
# Raw文字列
# 文字列をそのまま処理したい、表示したいときに使う文字列
# ポイント：R or rを"",''の前にくっつけるとエスケープシーケンスを無視できる
str_example_sentence = "これだと\n改行されちゃう"; print(str_example_sentence); 
# これだと
# 改行されちゃう

str_example_sentence = R"これだと\n改行されない"; print(str_example_sentence); 
# これだと\n改行されない。
# 初めてプログラミングを学んだとき、文字列末尾の\nを消したくて消したくてたまらなかったのを思い出した
# 当時、改行するための命令が必要なんだという思考に至らなかったのだと思う。
# 人間が直感的にできることを機械が分かる命令にするのが難しかった。

# * ---------------------------------------------------------- * #
# フォーマット文字列
# Python3.6以降で使える超便利もの。文字列の中に変数を突っ込んで、
# その値を後から文字列型なり、リスト型なり、辞書型なりで挿入することができる。バッチのログ吐き出したりするときに使えそう
# ポイント：""や''の前にf or Fを追加することで使えるようになる


item = "Pythonの入門書"
floor = 3 # なくても動くが、文字列に数字を連結するときはstr()関数で明示的に文字列化するようにしている
shelf = "技術書コーナー"
print(f"{item} は {floor}階の {shelf} にあります.") # Pythonの入門書 は 3階の 技術書コーナー にあります.
print(f"{item} は {str(floor)}階の {shelf} にあります.") # Pythonの入門書 は 3階の 技術書コーナー にあります.


# ポイント：演算や関数呼び出しもできる
a = 1
b = 3
print(f"a + b = {a + b}です") # a + b = 4です
print(f"円周率は、{math.pi}です") # 円周率は、3.141592653589793です

n = 100
k = 2
print(f"n個の玉の中から2つを選ぶ組み合わせは、{math.comb(n,k)} 通りです"); # n個の玉の中から2つを選ぶ組み合わせは、4950 通りです

# ポイント：フォーマット文字列の中で{}を使う場合は{{}}のように二重にする
print(f"次の選択肢のうち、適切なものを{{}}の中から選びなさい"); # 次の選択肢のうち、適切なものを{}の中から選びなさい

s = "文字列"
print(f"|{s}|") #|文字列|
print(f"|{s:<12}|") #|文字列         | 12文字の中で左寄せ
print(f"|{s:^12}|") #|    文字列     | 12文字の中で中央寄せ
print(f"|{s:>12}|") #|         文字列| 12文字の中で右寄せ

# こんなこともできる？
print(f"|{s:3>12}|") #|333333333文字列| 3埋めになるのか…
print(f"|{s:1^12}|") #|1111文字列11111| 1埋めになる

# ポイント：ゼロパディングってこんな実装するのかな…しない気がするけど
# -> zfill関数で一発でした。https://note.nkmk.me/python-zero-padding/
amount_of_sales = 749_271 # たとえば発注数をゼロパディングする
print(f"{amount_of_sales:0>12}") #000000749271 なんかそれっぽいです
amount_of_sales = 749_271_113_142_111 # たとえば発注数をゼロパディングする
print(f"{amount_of_sales:0>12}") #749271113142111 桁溢れは許容してしまいそうだ。桁数エラーで制御すればよし

# ポイント：ゼロパディングはzfillで一発簡単！注意点としては対象の数字は文字列化しておかないとならんこと
# zfillはstrクラスに付随した関数のため…
amount_of_sales = 749_271 # 発注数をゼロパディングする
print(str(amount_of_sales).zfill(12)) 

# ポイント：数値にカンマ区切りを入れたい！そんなときは
too_big_num = 123_456_789_012_345_678
print(f"¥{too_big_num:,}"); # ¥123,456,789,012,345,678 見事な3桁区切り

# ポイント：任意の数字を2進数、8真数、16進数(大文字)、16進数(小文字)にする
num = 255
print(f"{num:b}"); # 11111111
print(f"{num:o}"); # 377
print(f"{num:X}"); # FF
print(f"{num:x}"); # ff

# ポイント：#をつけると0b,0o,0x,0X表記にしてくれる
print(f"{num:#b}"); # 0b11111111
print(f"{num:#o}"); # 0o377
print(f"{num:#X}"); # 0XFF
print(f"{num:#x}"); # 0xff

# ポイント：数字をつけて表示桁数の設定ができる。
# ポイント：表示桁数の左に0をつけることでゼロパディングできる
num = 123
print(f"{num:08b}"); # 01111011
print(f"{num:08o}"); # 00000173
print(f"{num:08X}"); # 0000007B
print(f"{num:08x}"); # 0000007b


# ポイント： +は正の数に+、負の数に-をつける
#          -は正の数に何もつけず、負の数にのみ-をつける
num_a = 255
num_b = -255

print(f"{num_a:+},{num_b:+}"); # +255,-255
print(f"{num_a:-},{num_b:-}"); # 255,-255

# ポイント：浮動小数点表記は以下の通り、.2で2桁の小数を表現できる
#         fはfloat,eはExponentのe.Exponentは10のべき乗の意。
n = 12.3456
print(f"{n:.2f}")      # 12.35
print(f"{n:8.2f}")     #    12.35
print(f"{n:.2e}")      # 1.23e+01
print(f"{n:.2E}")      # 1.23E+01
print(f"{n:.2g}")      # 1.23
print(f"{n:.2%}")      # 1234.56%

# ポイント：日付の表現。なんならいっちゃん使う。ファイル名をユニークにするときの必需品
date_now = datetime.datetime.now() # 現在日時取得
print(f"{date_now}"); # 2024-11-24 20:15:45.530433
print(f"RECV_DAILY_STOCKDATA_{date_now:%Y%m%d%H%M%S%f}.csv"); # RECV_DAILY_STOCKDATA_20241124201720563511.csv

# ポイント：!sはstr(),!rはrepr(),!aはascii()の機能を持つ
# reprは引数付きのコンストラクタ（または初期化子）を文字列で返してくれる関数
value = "仕事はしたくないし、縁側でずっと昼寝だけしていたいし、来世はねこになりたい"
author = "えんがわ"
print(f"{value!s}--{author!s}")       # {str(value)} と同じ。ユーザ向けの出力文字列
# 仕事はしたくないし、縁側でずっと昼寝だけしていたいし、来世はねこになりたい--えんがわ

print(f"{value!r}--{author!r}")       # {repr(value)} と同じ。デバッガ向けの出力文字列
# '仕事はしたくないし、縁側でずっと昼寝だけしていたいし、来世はねこになりたい'--'えんがわ'

print(f"{value!a}--{author!a}")       # {ascii(value)} と同じ
# '\u4ed5\u4e8b\u306f\u3057\u305f\u304f\u306a\u3044\u3057\u3001\u7e01\u5074\u3067\u305a\u3063\u3068\u663c\u5bdd\u3060\u3051\u3057\u3066\u3044\u305f\u3044\u3057\u3001\u6765\u4e16\u306f\u306d\u3053\u306b\u306a\u308a\u305f\u3044'--'\u3048\u3093\u304c\u308f'

# ポイント：Python3.8より、変数のあとに=をつけると変数名もセットで表示してくれるように！
print(f"{value=!r}--{author=!r}")       # value='仕事はしたくないし、縁側でずっと昼寝だけしていたいし、来世はねこになりたい'--author='えんがわ'

# * ---------------------------------------------------------- * #
# バイト列
# バイト列っていつ使うの？って気持ちになることは多いですが、
# 主に、画像データなどのバイナリデータや、UTF-8 以外の文字コードの文字列を扱う扱うときに使います。
# たとえば、shift_jisで受け取ってutf-8に変換したい場合はクッソ重宝します。

# ポイント：バイト列から文字列に変換します
byte_string = b'\xe3\x81\x8d\xe3\x82\x8a\xe3\x81\x9f\xe3\x82\x93\xe3\x81\xbd\xe3\x81\x9f\xe3\x81\xb9\xe3\x81\x9f\xe3\x81\x84\xef\xbc\x81'
utf8_string = byte_string.decode()    # バイト列から文字列に変換
print(utf8_string) # きりたんぽたべたい！

# ポイント：文字列からバイト列に変換します
utf8_string = "きりたんぽたべたい！"
byte_string = utf8_string.encode()    # 文字列からバイト列に変換
print(byte_string) # b'\xe3\x81\x8d\xe3\x82\x8a\xe3\x81\x9f\xe3\x82\x93\xe3\x81\xbd\xe3\x81\x9f\xe3\x81\xb9\xe3\x81\x9f\xe3\x81\x84\xef\xbc\x81'

# ポイント：Unicode文字列からUTF8/SJIS/CP932/EUC/JISバイト列への変換
utf8_str = "きりたんぽたべたい！"
utf8_bytes = utf8_str.encode('utf-8'); print(utf8_bytes);             # UTF-8バイト列:      b'\xe3\x81\x8d\xe3\x82\x8a\xe3\x81\x9f\xe3\x82\x93\xe3\x81\xbd\xe3\x81\x9f\xe3\x81\xb9\xe3\x81\x9f\xe3\x81\x84\xef\xbc\x81'
sjis_bytes = utf8_str.encode('sjis'); print(sjis_bytes);              # Shift_JISバイト列:  b'\x82\xab\x82\xe8\x82\xbd\x82\xf1\x82\xdb\x82\xbd\x82\xd7\x82\xbd\x82\xa2\x81I'
cp932_bytes = utf8_str.encode('cp932'); print(cp932_bytes);           # CP932バイト列:      b'\x82\xab\x82\xe8\x82\xbd\x82\xf1\x82\xdb\x82\xbd\x82\xd7\x82\xbd\x82\xa2\x81I'
eucjp_bytes = utf8_str.encode('euc_jp'); print(eucjp_bytes);          # EUC-JPバイト列:     b'\xa4\xad\xa4\xea\xa4\xbf\xa4\xf3\xa4\xdd\xa4\xbf\xa4\xd9\xa4\xbf\xa4\xa4\xa1\xaa'
jis_bytes = utf8_str.encode('iso2022_jp'); print(jis_bytes);          # ISO-2022-JPバイト列:b'\x1b$B$-$j$?$s$]$?$Y$?$$!*\x1b(B'

# UTF8/SJIS/CP932/EUC/JISバイト列からUnicode文字列への変換
utf8_str = utf8_bytes.decode('utf-8'); print(utf8_str);              # きりたんぽたべたい！
utf8_str = sjis_bytes.decode('sjis'); print(utf8_str);               # きりたんぽたべたい！
utf8_str = cp932_bytes.decode('cp932'); print(utf8_str);             # きりたんぽたべたい！
utf8_str = eucjp_bytes.decode('euc_jp'); print(utf8_str);            # きりたんぽたべたい！
utf8_str = jis_bytes.decode('iso2022_jp'); print(utf8_str);          # きりたんぽたべたい！

# * ---------------------------------------------------------- * #
# Unicode文字列
# Python2.0で必須だったUnicode文字列。3.0ではデフォルトの文字列がUnicodeとしてみなされたため一時廃止となったが、互換性考慮のために3.3から復活。

# coding: utf-8
print(len("あいうえお"))        # Python 2だと15、Python 3だと5
print(len(u"あいうえお"))       # 5
# Unicode文字列の数え方について
# https://scrapbox.io/bbr-program-memo/Unicode%E3%81%AE%E6%96%87%E5%AD%97%E6%95%B0%E3%82%92%E6%AD%A3%E3%81%97%E3%81%8F%E6%95%B0%E3%81%88%E3%82%8B



# * ---------------------------------------------------------- * #
# 複数行文字列
# ポイント：3行クオート""",'''で複数行にまたがって文字列を記述することができる
str_haiku = "閑かさや　岩にしみ入る　蝉の声"; print(str_haiku); # 閑かさや　岩にしみ入る　蝉の声

str_haiku = """
    閑かさや　
        岩にしみ入る　
            蝉の声
"""; print(str_haiku); 
#
#    閑かさや　
#        岩にしみ入る　
#            蝉の声
#

# ポイント：バックスラッシュ\を打って複数行に分けることもできる
str_haiku = "閑かさや\n\
岩にしみ入る\n\
蝉の声\n"
print(str_haiku); 
# 閑かさや
# 岩にしみ入る
# 蝉の声

# * ---------------------------------------------------------- * #
# 文字列の連結
# ポイント：文字列と文字列の間に半角を入れるだけで連結できる！
print("やまだ" "たろう"); # やまだたろう
print("やまだ" "デイヴィット" "たろう"); # やまだデイヴィットたろう

# * ---------------------------------------------------------- * #
# エスケープシーケンス(\x)

# ポイント：使うときに見ればよし

# 垂直タブって綺麗だな　どこかで使いたい
print("私の名前は\v宇宙人\v——宇宙が苗字で\v人が名前だ")
#私の名前は
#          宇宙人
#                ——宇宙が苗字で
#                              人が名前だ
print("あ\fあ\bいい") # フォームフィードは改ページのことだよ
#あ
#   いい

# ベル文字とは…
# 本来の目的は、データの送信先にいるオペレータに何らかの通知（「今からメッセージを送る」など）するために、
# 相手側のストックティッカーやテレタイプ端末のベル（電鈴）を鳴らすことである。
# ストックティッカーはベル文字をティッカーテープに記録するが、プリンタはベル文字を受信してもそれを印字しなかった。
# ターミナルでtput belを入力したらビープ音が鳴ったので多分、このスクリプトをターミナル実行したら音が流れるはず
print("\a 警告だよ"); 
print("\a 警告だよ"); 
print("\a 警告だよ"); 
print("\a 警告だよ"); 



# \改行 : バックスラッシュと改行が無視される
# \\ : バックスラッシュ(\)
# \' : シングルクォート(')
# \" : ダブルクォート(")
# \a : ベル(BEL)
# \b : バックスペース(BS)
# \f : フォームフィード(FF) プリンターで改ページすること、またはそのための制御文字（FF)
# \n : 改行(LF)
# \r : 復帰(CR)
# \t : タブ(TAB)
# \v : 垂直タブ(VT)
# \nnn : 8進表記文字(nは0～7)
# \xnn : 16進表記文字(nは0～f)
# \uxxxx : ユニコード文字xxxx (例: u"\u3042")
# \Uxxxxxxxx : ユニコード文字xxxxxxxx (例: U"\U00003042")
# \N{name} : Unicodeデータベース文字 (例: u"\N{HIRAGANA LETTER A}")


# * ---------------------------------------------------------- * #
# 文字列のフォーマット(%)

# フォーマット文字列とはやや異なります。
# ポイント：文字列 % (変数1,変数2...)で文字列のフォーマットをすることができる

program_id = "BAT_SALES001"; 
# 処理実行中・・・エラー発生！
errlevel = "A"; errcode=94719; errmsg = f"{program_id} IS ABNOMAL END!";  
msg = """
ERROR:
-------------------
ERRLEVEL:%s
ERRCODE:(%d)
ERRMSG:%s
-------------------
""" % (errlevel, errcode,errmsg)
print(msg)     

# ERROR:
# -------------------
# ERRLEVEL:A
# ERRCODE:(94719)
# ERRMSG:BAT_SALES001 IS ABNOMAL END!
# -------------------

# 文字寄せを使ってエラーメッセージを整備してみる
errlevel = "C"; 
errcode=13403; 
errmsg = f"一括発注CSVデータに不正レコードがありました。";  
errcount = 2; 

msg = """
ERROR:
-------------------
ERRLEVEL:%10s
ERRCODE:(%10d)
ERRMSG:%s
ERRCOUNT:(%+010d)
-------------------
""" % (errlevel, errcode,errmsg,errcount)
print(msg)     
# こんな感じに整形
# ERROR:
# -------------------
# ERRLEVEL:         C
# ERRCODE:(     13403)
# ERRMSG:一括発注CSVデータに不正レコードがありました。
# ERRCOUNT:(+000000002)
# -------------------


print("|%50s|" % '東京都那由多代田区ギガ代田999-9999-9999')        # 右寄せ5文字分
print("|%-50s|" % '東京都那由多代田区ギガ代田999-9999-9999')       # 左寄せ5文字分
print("|%50d|" % 123456789)          # 右寄せ5桁
print("|%-50d|" % 123456789)         # 左寄せ5桁
print("|%+50d|" % 123456789)         # ±符号付き
print("|%+50d|" % -123456789)        # ±符号付き
print("|%-50d|" % 123456789)         # ±符号付き
print("|%-50d|" % -123456789)        # ±符号付き
print("|%50.4f|" % 123.456789)       # 全体桁数.少数点以下の桁数
print("|%050d|" % 123456789)         # 0埋め

# |                        東京都那由多代田区ギガ代田999-9999-9999|
# |東京都那由多代田区ギガ代田999-9999-9999                        |
# |                                         123456789|
# |123456789                                         |
# |                                        +123456789|
# |                                        -123456789|
# |123456789                                         |
# |-123456789                                        |
# |                                          123.4568|
# |00000000000000000000000000000000000000000123456789|